# Squint ClojureScript Dialect - AI Agent Instructions

This project uses [Squint](https://github.com/squint-cljs/squint), a light-weight ClojureScript dialect that compiles to modern JavaScript ES modules.

## Critical Differences from ClojureScript

* `name` function is not implemented.
* Keywords ARE Strings, so you don't need `name` for that

  ```clojure
  (str "status-" (:type status))  ; Works perfectly
  ```
* Data Structures Are Mutable JavaScript Objects

  Squint uses native JavaScript data structures:
  - Maps → JavaScript objects `{}`
  - Vectors → JavaScript arrays `[]`
  - Sets → JavaScript `Set`

  This means:
  - `assoc`, `conj`, etc. mutate in place (unlike ClojureScript)
  - Be aware when passing data structures around

* No Persistent Data Structures. There's no structural sharing or immutability guarantees. If you need immutability, explicitly clone data.

## Finding Squint Documentation

### Primary Sources

1. **GitHub Repository**: https://github.com/squint-cljs/squint
2. **README**: Comprehensive overview of features and differences
3. **Core Functions**: Check `src/squint/core.js` in the Squint repo for available functions

### Checking Function Availability

If unsure whether a Clojure core function exists in Squint:

1. **Search the Squint repo** for the function name in `src/squint/core.js`
2. **Check exports** - Functions must be explicitly exported to be available
3. **Test with Node.js** - Quick way to check if functions exist:

```bash
node -e "import('squint-cljs/core.js').then(sc => { \
  console.log('name:', typeof sc.name); \
  console.log('str:', typeof sc.str); \
  console.log('assoc:', typeof sc.assoc); \
})"
# Output:
# name: undefined    ← doesn't exist!
# str: function      ← exists
# assoc: function    ← exists
```

### Key Files in Squint Repo

- `src/squint/core.js` - Core runtime functions
- `src/squint/string.js` - String manipulation functions
- `doc/` - Additional documentation

## Common Gotchas

### 1. Unqualified Function Calls

When Squint doesn't recognize a symbol as a core function, it emits an unqualified call:

```clojure
(name :foo)  ; Compiles to: name("foo") - NOT squint_core.name("foo")
```

This causes runtime errors when `name` isn't defined globally.

### 2. Refer Doesn't Help for Missing Functions

```clojure
;; This does NOT make `name` available if it's not in squint-cljs/core.js
(:require [squint.core :refer [name]])
```

The require will silently succeed, but the function still won't exist at runtime.

### 3. Namespace Keywords

Namespace-qualified keywords work but become strings with the slash:

```clojure
:foo/bar  ; Becomes "foo/bar" in JavaScript
```

### 4. Auto-Resolved Keywords Don't Work

`::keyword` syntax is not supported. Use fully-qualified keywords instead:

```clojure
::my-key              ; ❌ Compiler error
:my-namespace/my-key  ; ✅ Works
```

### 5. Bare Namespace Requires Don't Work

Always use vector form with `:as` alias:

```clojure
(:require event-handler)                     ; ❌ Compiler error
(:require [event-handler :as event-handler]) ; ✅ Works
```

## Debugging Squint Issues

1. **Check compiled `.mjs` output** - Look at the generated JavaScript to understand what's happening
2. **Search for unqualified calls** - If you see `someFn(...)` instead of `squint_core.someFn(...)`, the function may not exist
3. **Browser DevTools** - Runtime errors will show which function is undefined

## Project-Specific Notes

In this project:
- Source files: `src/*.cljs`
- Compiled output: `extension/*.mjs`
- Bundled output: `build/*.js`

Never edit `.mjs` files directly - they're generated by Squint.

## Testing Code in Squint nREPL

Start the Squint nREPL server to test pure functions before editing files:

```bash
bb squint-nrepl  # Starts nREPL on port 1339
```

Connect your editor's nREPL client to `localhost:1339`, then test functions interactively:

```clojure
;; Test pure functions from url_matching.cljs
(require '[url-matching :refer [url-matches-pattern?]])
(url-matches-pattern? "https://github.com/foo" "*://github.com/*")
;; => true

;; Test storage helpers
(require '[storage :refer [generate-script-id]])
(generate-script-id "My Cool Script")
;; => "my-cool-script"
```

**What works in Squint nREPL:**
- Pure functions (data transformations, URL matching, ID generation)
- Core Squint functions (`map`, `filter`, `assoc`, etc.)
- String manipulation, regex operations

**What doesn't work:**
- Browser APIs (`chrome.*`, `document.*`, `window.*`)
- Extension-specific code (message passing, storage)
- Anything requiring the DOM

**Workflow:** Develop and test pure logic in the nREPL first, then integrate into browser-specific code with confidence.
